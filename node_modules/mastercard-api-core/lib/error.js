/*
 * Copyright 2016 MasterCard International.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of
 * conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 * Neither the name of the MasterCard International Incorporated nor the names of its
 * contributors may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/**
 * Error object for any API related issues.
 */
var APIError = function (msg, payload, status) {
    this.type = "APIError";
    this.message = msg;
    this.httpStatus = status;
    this.rawErrorData = payload;
    this._errors = parseErrors(payload);
    this.error = [];
    
    this.parseError = function(index) {
        if (this._errors && index >= 0 && index < this._errors.length) {
            this.error = this._errors[index];
        } else {
            this.error = {};
        }
    };
    
    this.getErrorSize = function() {
        return this._errors.length;
    }
    
    
    this.getError = function() {
        return this.error;
    };
    
    this.getRawErrorData = function() {
        return this.rawErrorData;
    }
    
    this.getReasonCode = function() {
        if ("reasoncode" in this.error) {
            return this.error["reasoncode"];
        } 
    };
    
    this.getMessage = function() {
        if ("description" in this.error) {
            return this.error["description"];
        } else {
            return this.message;
        }
    };
    
    this.getSource = function() {
        if ("source" in this.error) {
            return this.error["source"];
        } 
    };
    
    this.getHttpStatus = function() {
        return this.httpStatus;
    };
    
    this.parseError(0);
};

function parseErrors(errorData) {
    var errors = [];
    if (errorData instanceof Array) {
        errors = errorData;
    } else {
        errors.push(errorData);
    }
    
   
    
    
    var extractedErrors = [];
    for(var i = 0; i < errors.length; i++) {
        var errorMap = parseMap(errors[i]);
        
        //arizzini: so there can be
        //1) errors.error.reason
        //2) errors.error[].reason
        //3) errors[].reason
        //4) reason
        if ("errors" in errorMap) {
            //we need to check 1 / 2 / 3
            var errorsObject = errorMap["errors"];
            if (errorsObject instanceof Array) {
                //this takes care of 3
                extractedErrors = extractedErrors.concat(errorsObject);
            } else {
                //this is an object / dictionary, we need to check 1/2
                if ("error" in errorsObject) {
                    //then we take care of 2 / 3
                    var errorObject = errorsObject["error"];
                    if (errorObject instanceof Array) {
                        // take care of 2
                        extractedErrors = extractedErrors.concat(errorObject);
                    } else {
                        extractedErrors.push(errorObject);
                    }
                }
            }
        } else {
            extractedErrors.push(errorMap);
        }
 
    }
    
        
    return extractedErrors;
}

/**
 * This is the private function which re-parsed the map and makes it case-insensitive
 * @param {type} map
 * @returns {unresolved}
 */
function parseMap(map) {
    var result = {};
    for (var key in map) {
        var tmpObject = map[key];
        if (tmpObject instanceof Array) {
            result[key.toString().toLowerCase()] = parseList(tmpObject);
        } else if ( tmpObject instanceof Object) {
            result[key.toString().toLowerCase()] = parseMap(tmpObject);
        } else {
            result[key.toLowerCase()] = tmpObject;
        }
    }
    return result;
}
/**
 * This parse a list from list.
 * @param {type} list
 * @returns {Array|nm$error.parseList.result|parseList.result}
 */
function parseList(list) {
    var result = []
    for (var i = 0; i < list.length; i++) {
        var item = list[i];
        if (item instanceof Array) {
            result.push(parseList(item));
        } else if ( item instanceof Object) {
            result.push(parseMap(item));
        } else {
            result.push(item);
        }
    }
    return result;
}

/**
 * Error object for any SDK related issues.
 */
var SDKError = function (msg) {
    this.type = "SDKError";
    this.message = msg;
};

module.exports = {
    APIError: APIError,
    SDKError: SDKError
};